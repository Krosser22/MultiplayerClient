<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Example">Example</a></li>
      <li><a href="#Philosophy">Philosophy</a></li>
    </ul>
  </li>
  <li><a href="#Details">Details</a>
    <ul>
      <li><a href="#Template-Parsing">Template Parsing</a></li>
      <li><a href="#The-OUT-variable">The $OUT variable</a></li>
      <li><a href="#General-Remarks">General Remarks</a></li>
      <li><a href="#new">new</a></li>
      <li><a href="#compile">compile</a></li>
      <li><a href="#fill_in">fill_in</a></li>
    </ul>
  </li>
  <li><a href="#Convenience-Functions">Convenience Functions</a>
    <ul>
      <li><a href="#fill_this_in">fill_this_in</a></li>
      <li><a href="#fill_in_string">fill_in_string</a></li>
      <li><a href="#fill_in_file">fill_in_file</a></li>
      <li><a href="#Including-files-into-templates">Including files into templates</a></li>
    </ul>
  </li>
  <li><a href="#Miscellaneous">Miscellaneous</a>
    <ul>
      <li><a href="#my-variables">my variables</a></li>
      <li><a href="#Security-Matters">Security Matters</a></li>
      <li><a href="#Alternative-Delimiters">Alternative Delimiters</a></li>
      <li><a href="#PREPEND-feature-and-using-strict-in-templates">PREPEND feature and using strict in templates</a></li>
      <li><a href="#Prepending-in-Derived-Classes">Prepending in Derived Classes</a></li>
      <li><a href="#JavaScript">JavaScript</a></li>
      <li><a href="#Shut-Up">Shut Up!</a></li>
      <li><a href="#Compatibility">Compatibility</a></li>
      <li><a href="#Backslash-Processing">Backslash Processing</a></li>
      <li><a href="#A-short-note-about-Text::Template::ERROR">A short note about $Text::Template::ERROR</a></li>
      <li><a href="#Sticky-Widgets-in-Template-Files">Sticky Widgets in Template Files</a></li>
      <li><a href="#Automatic-preprocessing-of-program-fragments">Automatic preprocessing of program fragments</a></li>
      <li><a href="#Automatic-postprocessing-of-template-hunks">Automatic postprocessing of template hunks</a></li>
      <li><a href="#Author">Author</a></li>
      <li><a href="#Support">Support?</a></li>
    </ul>
  </li>
  <li><a href="#LICENSE">LICENSE</a></li>
  <li><a href="#THANKS">THANKS</a>
    <ul>
      <li><a href="#Bugs-and-Caveats">Bugs and Caveats</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Text::Template - Expand template text with embedded Perl</p>

<h1 id="VERSION">VERSION</h1>

<p>This file documents <code>Text::Template</code> version <b>1.46</b></p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> <span class="keyword">use</span> <span class="variable">Text::Template</span><span class="operator">;</span>
 
 
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'FILE'</span><span class="operator">,</span>  <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="string">'filename.tmpl'</span><span class="operator">);</span>
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'ARRAY'</span><span class="operator">,</span> <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="operator">...</span> <span class="operator">]</span> <span class="operator">);</span>
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'FILEHANDLE'</span><span class="operator">,</span> <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="variable">$fh</span> <span class="operator">);</span>
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'STRING'</span><span class="operator">,</span> <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="string">'...'</span> <span class="operator">);</span>
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">PREPEND</span> <span class="operator">=&gt;</span> <span class="string">q{use strict;}</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="comment"># Use a different template file syntax:</span>
 <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">DELIMITERS</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="variable">$open</span><span class="operator">,</span> <span class="variable">$close</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="variable">$recipient</span> <span class="operator">=</span> <span class="string">'King'</span><span class="operator">;</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">();</span>  <span class="comment"># Replaces `{$recipient}' with `King'</span>
 <span class="keyword">print</span> <span class="variable">$text</span><span class="operator">;</span>
 
 <span class="variable">$T::recipient</span> <span class="operator">=</span> <span class="string">'Josh'</span><span class="operator">;</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">PACKAGE</span> <span class="operator">=&gt;</span> <span class="variable">T</span><span class="operator">);</span>
 
 <span class="comment"># Pass many variables explicitly</span>
 <span class="variable">$hash</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">recipient</span> <span class="operator">=&gt;</span> <span class="string">'Abed-Nego'</span><span class="operator">,</span>
           <span class="string">friends</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">'me'</span><span class="operator">,</span> <span class="string">'you'</span> <span class="operator">]</span><span class="operator">,</span>
           <span class="string">enemies</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">loathsome</span> <span class="operator">=&gt;</span> <span class="string">'Bill Gates'</span><span class="operator">,</span>
                        <span class="string">fearsome</span> <span class="operator">=&gt;</span> <span class="string">'Larry Ellison'</span> <span class="operator">}</span><span class="operator">,</span>
         <span class="operator">}</span><span class="operator">;</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="variable">$hash</span><span class="operator">,</span> <span class="operator">...);</span>
 <span class="comment"># $recipient is Abed-Nego,</span>
 <span class="comment"># @friends is ( 'me', 'you' ),</span>
 <span class="comment"># %enemies is ( loathsome =&gt; ..., fearsome =&gt; ... )</span>
 
 
 <span class="comment"># Call &amp;callback in case of programming errors in template</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">BROKEN</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback</span><span class="operator">,</span> <span class="string">BROKEN_ARG</span> <span class="operator">=&gt;</span> <span class="variable">$ref</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="comment"># Evaluate program fragments in Safe compartment with restricted permissions</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">SAFE</span> <span class="operator">=&gt;</span> <span class="variable">$compartment</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="comment"># Print result text instead of returning it</span>
 <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">OUTPUT</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">*FILEHANDLE</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="comment"># Parse template with different template file syntax:</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">DELIMITERS</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="variable">$open</span><span class="operator">,</span> <span class="variable">$close</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">...);</span>
 <span class="comment"># Note that this is *faster* than using the default delimiters</span>
 
 <span class="comment"># Prepend specified perl code to each fragment before evaluating:</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">PREPEND</span> <span class="operator">=&gt;</span> <span class="string">q{use strict 'vars';}</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="keyword">use</span> <span class="variable">Text::Template</span> <span class="string">'fill_in_string'</span><span class="operator">;</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_string</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">EOM</span><span class="operator">,</span> <span class="string">PACKAGE</span> <span class="operator">=&gt;</span> <span class="string">'T'</span><span class="operator">,</span> <span class="operator">...);</span><span class="string">
 Dear {$recipient},
 Pay me at once.
        Love, 
         G.V.
 </span><span class="default">EOM</span>
 
 <span class="keyword">use</span> <span class="variable">Text::Template</span> <span class="string">'fill_in_file'</span><span class="operator">;</span>
 <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_file</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">,</span> <span class="operator">...);</span>
 
 <span class="comment"># All templates will always have `use strict vars' attached to all fragments</span>
 <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">always_prepend</span><span class="operator">(</span><span class="string">q{use strict 'vars';}</span><span class="operator">);</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This is a library for generating form letters, building HTML pages, or filling in templates generally. A `template&#39; is a piece of text that has little Perl programs embedded in it here and there. When you `fill in&#39; a template, you evaluate the little programs and replace them with their values.</p>

<p>You can store a template in a file outside your program. People can modify the template without modifying the program. You can separate the formatting details from the main code, and put the formatting parts of the program into the template. That prevents code bloat and encourages functional separation.</p>

<h2 id="Example">Example</h2>

<p>Here&#39;s an example of a template, which we&#39;ll suppose is stored in the file <code>formletter.tmpl</code>:</p>

<pre><code>        <span class="variable">Dear</span> <span class="operator">{</span><span class="variable">$title</span><span class="operator">}</span> <span class="operator">{</span><span class="variable">$lastname</span><span class="operator">}</span><span class="operator">,</span>
        
        <span class="variable">It</span> <span class="variable">has</span> <span class="variable">come</span> <span class="variable">to</span> <span class="keyword">our</span> <span class="variable">attention</span> <span class="variable">that</span> <span class="variable">you</span> <span class="variable">are</span> <span class="variable">delinquent</span> <span class="variable">in</span> <span class="variable">your</span>
        <span class="operator">{</span><span class="variable">$monthname</span><span class="operator">[</span><span class="variable">$last_paid_month</span><span class="operator">]</span><span class="operator">}</span> <span class="variable">payment</span><span class="operator">.</span>  <span class="variable">Please</span> <span class="variable">remit</span>
        <span class="variable">$</span><span class="operator">{</span><span class="keyword">sprintf</span><span class="operator">(</span><span class="string">"%.2f"</span><span class="operator">,</span> <span class="variable">$amount</span><span class="operator">)</span><span class="operator">}</span> <span class="variable">immediately</span><span class="operator">,</span> <span class="keyword">or</span> <span class="variable">your</span> <span class="variable">patellae</span> <span class="variable">may</span>
        <span class="variable">be</span> <span class="variable">needlessly</span> <span class="variable">endangered</span><span class="operator">.</span>
        
                        <span class="variable">Love</span><span class="operator">,</span>
        
                        <span class="variable">Mark</span> <span class="string">"Vizopteryx"</span> <span class="variable">Dominus</span>
</code></pre>

<p>The result of filling in this template is a string, which might look something like this:</p>

<pre><code>        Dear Mr. Gates,

        It has come to our attention that you are delinquent in your
        February payment.  Please remit
        $392.12 immediately, or your patellae may
        be needlessly endangered.


                        Love,

                        Mark &quot;Vizopteryx&quot; Dominus</code></pre>

<p>Here is a complete program that transforms the example template into the example result, and prints it out:</p>

<pre><code>        <span class="keyword">use</span> <span class="variable">Text::Template</span><span class="operator">;</span>
        
        <span class="keyword">my</span> <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="string">'formletter.tmpl'</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't construct template: </span><span class="variable">$Text</span><span class="string">::Template::ERROR"</span><span class="operator">;</span>
        
        <span class="keyword">my</span> <span class="variable">@monthname</span> <span class="operator">=</span> <span class="string">qw(January February March April May June
                           July August September October November December)</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">%vars</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">title</span> <span class="operator">=&gt;</span> <span class="string">'Mr.'</span><span class="operator">,</span>
                    <span class="string">firstname</span> <span class="operator">=&gt;</span> <span class="string">'Bill'</span><span class="operator">,</span>
                    <span class="string">lastname</span> <span class="operator">=&gt;</span> <span class="string">'Gates'</span><span class="operator">,</span>
                    <span class="string">last_paid_month</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>   <span class="comment"># February</span>
                    <span class="string">amount</span> <span class="operator">=&gt;</span> <span class="number">392.12</span><span class="operator">,</span>
                    <span class="string">monthname</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@monthname</span><span class="operator">,</span>
                   <span class="operator">);</span>
        
        <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">%vars</span><span class="operator">);</span>
        
        <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$result</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="variable">$result</span> <span class="operator">}</span>
        <span class="keyword">else</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"Couldn't fill in template: </span><span class="variable">$Text</span><span class="string">::Template::ERROR"</span> <span class="operator">}</span>
</code></pre>

<h2 id="Philosophy">Philosophy</h2>

<p>When people make a template module like this one, they almost always start by inventing a special syntax for substitutions. For example, they build it so that a string like <code>%%VAR%%</code> is replaced with the value of <code>$VAR</code>. Then they realize the need extra formatting, so they put in some special syntax for formatting. Then they need a loop, so they invent a loop syntax. Pretty soon they have a new little template language.</p>

<p>This approach has two problems: First, their little language is crippled. If you need to do something the author hasn&#39;t thought of, you lose. Second: Who wants to learn another language? You already know Perl, so why not use it?</p>

<p><code>Text::Template</code> templates are programmed in <i>Perl</i>. You embed Perl code in your template, with <code><span class="operator">{</span>
</code> at the beginning and <code>}</code> at the end. If you want a variable interpolated, you write it the way you would in Perl. If you need to make a loop, you can use any of the Perl loop constructions. All the Perl built-in functions are available.</p>

<h1 id="Details">Details</h1>

<h2 id="Template-Parsing">Template Parsing</h2>

<p>The <code>Text::Template</code> module scans the template source. An open brace <code><span class="operator">{</span>
</code> begins a program fragment, which continues until the matching close brace <code>}</code>. When the template is filled in, the program fragments are evaluated, and each one is replaced with the resulting value to yield the text that is returned.</p>

<p>A backslash <code>\</code> in front of a brace (or another backslash that is in front of a brace) escapes its special meaning. The result of filling out this template:</p>

<pre><code>        <span class="operator">\</span><span class="operator">{</span> <span class="variable">The</span> <span class="variable">sum</span> <span class="variable">of</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> <span class="variable">is</span> <span class="operator">{</span><span class="number">1</span><span class="operator">+</span><span class="number">2</span><span class="operator">}</span>  <span class="operator">\</span><span class="operator">}</span>
</code></pre>

<p>is</p>

<pre><code>        <span class="operator">{</span> <span class="variable">The</span> <span class="variable">sum</span> <span class="variable">of</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> <span class="variable">is</span> <span class="number">3</span>  <span class="operator">}</span>
</code></pre>

<p>If you have an unmatched brace, <code>Text::Template</code> will return a failure code and a warning about where the problem is. Backslashes that do not precede a brace are passed through unchanged. If you have a template like this:</p>

<pre><code>        <span class="operator">{</span> <span class="string">"String that ends in a newline.\n"</span> <span class="operator">}</span>
</code></pre>

<p>The backslash inside the string is passed through to Perl unchanged, so the <code>\n</code> really does turn into a newline. See the note at the end for details about the way backslashes work. Backslash processing is <i>not</i> done when you specify alternative delimiters with the <code>DELIMITERS</code> option. (See <a href="#Alternative-Delimiters">&quot;Alternative Delimiters&quot;</a>, below.)</p>

<p>Each program fragment should be a sequence of Perl statements, which are evaluated the usual way. The result of the last statement executed will be evaluted in scalar context; the result of this statement is a string, which is interpolated into the template in place of the program fragment itself.</p>

<p>The fragments are evaluated in order, and side effects from earlier fragments will persist into later fragments:</p>

<pre><code>        <span class="operator">{</span><span class="variable">$x</span> <span class="operator">=</span> <span class="variable">@things</span><span class="operator">;</span> <span class="string">''</span><span class="operator">}</span><span class="variable">The</span> <span class="variable">Lord</span> <span class="variable">High</span> <span class="variable">Chamberlain</span> <span class="variable">has</span> <span class="variable">gotten</span> <span class="operator">{</span><span class="variable">$x</span><span class="operator">}</span>
        <span class="variable">things</span> <span class="keyword">for</span> <span class="variable">me</span> <span class="variable">this</span> <span class="variable">year</span><span class="operator">.</span>  
        <span class="operator">{</span> <span class="variable">$diff</span> <span class="operator">=</span> <span class="variable">$x</span> <span class="operator">-</span> <span class="number">17</span><span class="operator">;</span> 
          <span class="variable">$more</span> <span class="operator">=</span> <span class="string">'more'</span>
          <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$diff</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$diff</span> <span class="operator">=</span> <span class="string">'no'</span><span class="operator">;</span>
          <span class="operator">}</span> <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$diff</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$more</span> <span class="operator">=</span> <span class="string">'fewer'</span><span class="operator">;</span>
          <span class="operator">}</span> 
          <span class="string">''</span><span class="operator">;</span>
        <span class="operator">}</span> 
        <span class="variable">That</span> <span class="variable">is</span> <span class="operator">{</span><span class="variable">$diff</span><span class="operator">}</span> <span class="operator">{</span><span class="variable">$more</span><span class="operator">}</span> <span class="variable">than</span> <span class="variable">he</span> <span class="variable">gave</span> <span class="variable">me</span> <span class="keyword">last</span> <span class="variable">year</span><span class="operator">.</span>
</code></pre>

<p>The value of <code>$x</code> set in the first line will persist into the next fragment that begins on the third line, and the values of <code>$diff</code> and <code>$more</code> set in the second fragment will persist and be interpolated into the last line. The output will look something like this:</p>

<pre><code>        The Lord High Chamberlain has gotten 42
        things for me this year.  

        That is 25 more than he gave me last year.</code></pre>

<p>That is all the syntax there is.</p>

<h2 id="The-OUT-variable">The <code>$OUT</code> variable</h2>

<p>There is one special trick you can play in a template. Here is the motivation for it: Suppose you are going to pass an array, <code>@items</code>, into the template, and you want the template to generate a bulleted list with a header, like this:</p>

<pre><code>        Here is a list of the things I have got for you since 1907:
          * Ivory
          * Apes
          * Peacocks
          * ...</code></pre>

<p>One way to do it is with a template like this:</p>

<pre><code>        <span class="variable">Here</span> <span class="variable">is</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">things</span> <span class="variable">I</span> <span class="variable">have</span> <span class="variable">got</span> <span class="keyword">for</span> <span class="variable">you</span> <span class="variable">since</span> <span class="number">1907</span><span class="operator">:</span>
        <span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$blist</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
          <span class="keyword">foreach</span> <span class="variable">$i</span> <span class="operator">(</span><span class="variable">@items</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$blist</span> <span class="operator">.=</span> <span class="string">qq{  * </span><span class="variable">$i</span><span class="string">\n}</span><span class="operator">;</span>
          <span class="operator">}</span>    
          <span class="variable">$blist</span><span class="operator">;</span>
        <span class="operator">}</span> 
</code></pre>

<p>Here we construct the list in a variable called <code>$blist</code>, which we return at the end. This is a little cumbersome. There is a shortcut.</p>

<p>Inside of templates, there is a special variable called <code>$OUT</code>. Anything you append to this variable will appear in the output of the template. Also, if you use <code>$OUT</code> in a program fragment, the normal behavior, of replacing the fragment with its return value, is disabled; instead the fragment is replaced with the value of <code>$OUT</code>. This means that you can write the template above like this:</p>

<pre><code>        <span class="variable">Here</span> <span class="variable">is</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">things</span> <span class="variable">I</span> <span class="variable">have</span> <span class="variable">got</span> <span class="keyword">for</span> <span class="variable">you</span> <span class="variable">since</span> <span class="number">1907</span><span class="operator">:</span>
        <span class="operator">{</span> <span class="keyword">foreach</span> <span class="variable">$i</span> <span class="operator">(</span><span class="variable">@items</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$OUT</span> <span class="operator">.=</span> <span class="string">"  * </span><span class="variable">$i</span><span class="string">\n"</span><span class="operator">;</span>
          <span class="operator">}</span>    
        <span class="operator">}</span> 
</code></pre>

<p><code>$OUT</code> is reinitialized to the empty string at the start of each program fragment. It is private to <code>Text::Template</code>, so you can&#39;t use a variable named <code>$OUT</code> in your template without invoking the special behavior.</p>

<h2 id="General-Remarks">General Remarks</h2>

<p>All <code>Text::Template</code> functions return <code>undef</code> on failure, and set the variable <code>$Text::Template::ERROR</code> to contain an explanation of what went wrong. For example, if you try to create a template from a file that does not exist, <code>$Text::Template::ERROR</code> will contain something like:</p>

<pre><code>        Couldn&#39;t open file xyz.tmpl: No such file or directory</code></pre>

<h2 id="new"><code>new</code></h2>

<pre><code>        <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span> <span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="operator">...,</span> <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">);</span>
</code></pre>

<p>This creates and returns a new template object. <code>new</code> returns <code>undef</code> and sets <code>$Text::Template::ERROR</code> if it can&#39;t create the template object. <code>SOURCE</code> says where the template source code will come from. <code>TYPE</code> says what kind of object the source is.</p>

<p>The most common type of source is a file:</p>

<pre><code>        <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span> <span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'FILE'</span><span class="operator">,</span> <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="variable">$filename</span> <span class="operator">);</span>
</code></pre>

<p>This reads the template from the specified file. The filename is opened with the Perl <code>open</code> command, so it can be a pipe or anything else that makes sense with <code>open</code>.</p>

<p>The <code>TYPE</code> can also be <code>STRING</code>, in which case the <code>SOURCE</code> should be a string:</p>

<pre><code>        <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span> <span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'STRING'</span><span class="operator">,</span> 
                             <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="string">"This is the actual template!"</span> <span class="operator">);</span>
</code></pre>

<p>The <code>TYPE</code> can be <code>ARRAY</code>, in which case the source should be a reference to an array of strings. The concatenation of these strings is the template:</p>

<pre><code>        <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span> <span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'ARRAY'</span><span class="operator">,</span> 
                             <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">"This is "</span><span class="operator">,</span> <span class="string">"the actual"</span><span class="operator">,</span> 
                                         <span class="string">" template!"</span><span class="operator">,</span>
                                       <span class="operator">]</span>
                           <span class="operator">);</span>
</code></pre>

<p>The <code>TYPE</code> can be FILEHANDLE, in which case the source should be an open filehandle (such as you got from the <code>FileHandle</code> or <code>IO::*</code> packages, or a glob, or a reference to a glob). In this case <code>Text::Template</code> will read the text from the filehandle up to end-of-file, and that text is the template:</p>

<pre><code>        <span class="comment"># Read template source code from STDIN:</span>
        <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span> <span class="string">TYPE</span> <span class="operator">=&gt;</span> <span class="string">'FILEHANDLE'</span><span class="operator">,</span> 
                             <span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">*STDIN</span>  <span class="operator">);</span>
</code></pre>

<p>If you omit the <code>TYPE</code> attribute, it&#39;s taken to be <code>FILE</code>. <code>SOURCE</code> is required. If you omit it, the program will abort.</p>

<p>The words <code>TYPE</code> and <code>SOURCE</code> can be spelled any of the following ways:</p>

<pre><code>        TYPE    SOURCE
        Type    Source
        type    source
        -TYPE   -SOURCE
        -Type   -Source
        -type   -source</code></pre>

<p>Pick a style you like and stick with it.</p>

<dl>

<dt id="DELIMITERS"><code>DELIMITERS</code></dt>
<dd>

<p>You may also add a <code>DELIMITERS</code> option. If this option is present, its value should be a reference to an array of two strings. The first string is the string that signals the beginning of each program fragment, and the second string is the string that signals the end of each program fragment. See <a href="#Alternative-Delimiters">&quot;Alternative Delimiters&quot;</a>, below.</p>

</dd>
<dt id="UNTAINT"><code>UNTAINT</code></dt>
<dd>

<p>If your program is running in taint mode, you may have problems if your templates are stored in files. Data read from files is considered &#39;untrustworthy&#39;, and taint mode will not allow you to evaluate the Perl code in the file. (It is afraid that a malicious person might have tampered with the file.)</p>

<p>In some environments, however, local files are trustworthy. You can tell <code>Text::Template</code> that a certain file is trustworthy by supplying <code>UNTAINT =&gt; 1</code> in the call to <code>new</code>. This will tell <code>Text::Template</code> to disable taint checks on template code that has come from a file, as long as the filename itself is considered trustworthy. It will also disable taint checks on template code that comes from a filehandle. When used with <code>TYPE =&gt; &#39;string&#39;</code> or <code>TYPE =&gt; &#39;array&#39;</code>, it has no effect.</p>

<p>See <a href="../../../lib/pods/perlsec.html">perlsec</a> for more complete information about tainting.</p>

<p>Thanks to Steve Palincsar, Gerard Vreeswijk, and Dr. Christoph Baehr for help with this feature.</p>

</dd>
<dt id="PREPEND"><code>PREPEND</code></dt>
<dd>

<p>This option is passed along to the <code>fill_in</code> call unless it is overridden in the arguments to <code>fill_in</code>. See <a href="#PREPEND-feature-and-using-strict-in-templates">&quot;<code>PREPEND</code> feature and using <code>strict</code> in templates&quot;</a> below.</p>

</dd>
<dt id="BROKEN"><code>BROKEN</code></dt>
<dd>

<p>This option is passed along to the <code>fill_in</code> call unless it is overridden in the arguments to <code>fill_in</code>. See <a><code>BROKEN</code></a> below.</p>

</dd>
</dl>

<h2 id="compile"><code>compile</code></h2>

<pre><code>        $template-&gt;compile()</code></pre>

<p>Loads all the template text from the template&#39;s source, parses and compiles it. If successful, returns true; otherwise returns false and sets <code>$Text::Template::ERROR</code>. If the template is already compiled, it returns true and does nothing.</p>

<p>You don&#39;t usually need to invoke this function, because <code>fill_in</code> (see below) compiles the template if it isn&#39;t compiled already.</p>

<p>If there is an argument to this function, it must be a reference to an array containing alternative delimiter strings. See <code>&quot;Alternative Delimiters&quot;</code>, below.</p>

<h2 id="fill_in"><code>fill_in</code></h2>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="variable">OPTIONS</span><span class="operator">);</span>
</code></pre>

<p>Fills in a template. Returns the resulting text if successful. Otherwise, returns <code>undef</code> and sets <code>$Text::Template::ERROR</code>.</p>

<p>The <i>OPTIONS</i> are a hash, or a list of key-value pairs. You can write the key names in any of the six usual styles as above; this means that where this manual says <code>PACKAGE</code> (for example) you can actually use any of</p>

<pre><code>        PACKAGE Package package -PACKAGE -Package -package</code></pre>

<p>Pick a style you like and stick with it. The all-lowercase versions may yield spurious warnings about</p>

<pre><code>        Ambiguous use of package =&gt; resolved to &quot;package&quot;</code></pre>

<p>so you might like to avoid them and use the capitalized versions.</p>

<p>At present, there are eight legal options: <code>PACKAGE</code>, <code>BROKEN</code>, <code>BROKEN_ARG</code>, <code>SAFE</code>, <code>HASH</code>, <code>OUTPUT</code>, and <code>DELIMITERS</code>.</p>

<dl>

<dt id="PACKAGE"><code>PACKAGE</code></dt>
<dd>

<p><code>PACKAGE</code> specifies the name of a package in which the program fragments should be evaluated. The default is to use the package from which <code>fill_in</code> was called. For example, consider this template:</p>

<pre><code>        <span class="variable">The</span> <span class="variable">value</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">variable</span> <span class="operator">x</span> <span class="variable">is</span> <span class="operator">{</span><span class="variable">$x</span><span class="operator">}.</span>
</code></pre>

<p>If you use <code>$template-&gt;fill_in(PACKAGE =&gt; &#39;R&#39;)</code> , then the <code>$x</code> in the template is actually replaced with the value of <code>$R::x</code>. If you omit the <code>PACKAGE</code> option, <code>$x</code> will be replaced with the value of the <code>$x</code> variable in the package that actually called <code>fill_in</code>.</p>

<p>You should almost always use <code>PACKAGE</code>. If you don&#39;t, and your template makes changes to variables, those changes will be propagated back into the main program. Evaluating the template in a private package helps prevent this. The template can still modify variables in your program if it wants to, but it will have to do so explicitly. See the section at the end on `Security&#39;.</p>

<p>Here&#39;s an example of using <code>PACKAGE</code>:</p>

<pre><code>        <span class="variable">Your</span> <span class="variable">Royal</span> <span class="variable">Highness</span><span class="operator">,</span>
        
        <span class="variable">Enclosed</span> <span class="variable">please</span> <span class="variable">find</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">things</span> <span class="variable">I</span> <span class="variable">have</span> <span class="variable">gotten</span>
        <span class="keyword">for</span> <span class="variable">you</span> <span class="variable">since</span> <span class="number">1907</span><span class="operator">:</span>
        
        <span class="operator">{</span> <span class="keyword">foreach</span> <span class="variable">$item</span> <span class="operator">(</span><span class="variable">@items</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$item_no</span><span class="operator">++;</span>
            <span class="variable">$OUT</span> <span class="operator">.=</span> <span class="string">" </span><span class="variable">$item_no</span><span class="string">. \u</span><span class="variable">$item</span><span class="string">\n"</span><span class="operator">;</span>
          <span class="operator">}</span>
        <span class="operator">}</span>
        
        <span class="variable">Signed</span><span class="operator">,</span>
        <span class="variable">Lord</span> <span class="variable">High</span> <span class="variable">Chamberlain</span>
</code></pre>

<p>We want to pass in an array which will be assigned to the array <code>@items</code>. Here&#39;s how to do that:</p>

<pre><code>        <span class="variable">@items</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">'ivory'</span><span class="operator">,</span> <span class="string">'apes'</span><span class="operator">,</span> <span class="string">'peacocks'</span><span class="operator">,</span> <span class="operator">);</span>
        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">();</span>
</code></pre>

<p>This is not very safe. The reason this isn&#39;t as safe is that if you had a variable named <code>$item_no</code> in scope in your program at the point you called <code>fill_in</code>, its value would be clobbered by the act of filling out the template. The problem is the same as if you had written a subroutine that used those variables in the same way that the template does. (<code>$OUT</code> is special in templates and is always safe.)</p>

<p>One solution to this is to make the <code>$item_no</code> variable private to the template by declaring it with <code>my</code>. If the template does this, you are safe.</p>

<p>But if you use the <code>PACKAGE</code> option, you will probably be safe even if the template does <i>not</i> declare its variables with <code>my</code>:</p>

<pre><code>        <span class="variable">@Q::items</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">'ivory'</span><span class="operator">,</span> <span class="string">'apes'</span><span class="operator">,</span> <span class="string">'peacocks'</span><span class="operator">,</span> <span class="operator">);</span>
        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">PACKAGE</span> <span class="operator">=&gt;</span> <span class="string">'Q'</span><span class="operator">);</span>
</code></pre>

<p>In this case the template will clobber the variable <code>$Q::item_no</code>, which is not related to the one your program was using.</p>

<p>Templates cannot affect variables in the main program that are declared with <code>my</code>, unless you give the template references to those variables.</p>

</dd>
<dt id="HASH"><code>HASH</code></dt>
<dd>

<p>You may not want to put the template variables into a package. Packages can be hard to manage: You can&#39;t copy them, for example. <code>HASH</code> provides an alternative.</p>

<p>The value for <code>HASH</code> should be a reference to a hash that maps variable names to values. For example,</p>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">recipient</span> <span class="operator">=&gt;</span> <span class="string">"The King"</span><span class="operator">,</span>
                                     <span class="string">items</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'gold'</span><span class="operator">,</span> <span class="string">'frankincense'</span><span class="operator">,</span> <span class="string">'myrrh'</span><span class="operator">]</span><span class="operator">,</span>
                                     <span class="string">object</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$self</span><span class="operator">,</span>
                                   <span class="operator">}</span><span class="operator">);</span>
</code></pre>

<p>will fill out the template and use <code>&quot;The King&quot;</code> as the value of <code>$recipient</code> and the list of items as the value of <code>@items</code>. Note that we pass an array reference, but inside the template it appears as an array. In general, anything other than a simple string or number should be passed by reference.</p>

<p>We also want to pass an object, which is in <code>$self</code>; note that we pass a reference to the object, <code>\$self</code> instead. Since we&#39;ve passed a reference to a scalar, inside the template the object appears as <code>$object</code>.</p>

<p>The full details of how it works are a little involved, so you might want to skip to the next section.</p>

<p>Suppose the key in the hash is <i>key</i> and the value is <i>value</i>.</p>

<ul>

<li><p>If the <i>value</i> is <code>undef</code>, then any variables named <code>$key</code>, <code>@key</code>, <code>%key</code>, etc., are undefined.</p>

</li>
<li><p>If the <i>value</i> is a string or a number, then <code>$key</code> is set to that value in the template.</p>

</li>
<li><p>For anything else, you must pass a reference.</p>

<p>If the <i>value</i> is a reference to an array, then <code>@key</code> is set to that array. If the <i>value</i> is a reference to a hash, then <code>%key</code> is set to that hash. Similarly if <i>value</i> is any other kind of reference. This means that</p>

<pre><code>        var =&gt; &quot;foo&quot;</code></pre>

<p>and</p>

<pre><code>        var =&gt; \&quot;foo&quot;</code></pre>

<p>have almost exactly the same effect. (The difference is that in the former case, the value is copied, and in the latter case it is aliased.)</p>

</li>
<li><p>In particular, if you want the template to get an object or any kind, you must pass a reference to it:</p>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">database_handle</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="operator">...</span> <span class="operator">}</span><span class="operator">);</span>
</code></pre>

<p>If you do this, the template will have a variable <code>$database_handle</code> which is the database handle object. If you leave out the <code>\</code>, the template will have a hash <code>%database_handle</code>, which exposes the internal structure of the database handle object; you don&#39;t want that.</p>

</li>
</ul>

<p>Normally, the way this works is by allocating a private package, loading all the variables into the package, and then filling out the template as if you had specified that package. A new package is allocated each time. However, if you <i>also</i> use the <code>PACKAGE</code> option, <code>Text::Template</code> loads the variables into the package you specified, and they stay there after the call returns. Subsequent calls to <code>fill_in</code> that use the same package will pick up the values you loaded in.</p>

<p>If the argument of <code>HASH</code> is a reference to an array instead of a reference to a hash, then the array should contain a list of hashes whose contents are loaded into the template package one after the other. You can use this feature if you want to combine several sets of variables. For example, one set of variables might be the defaults for a fill-in form, and the second set might be the user inputs, which override the defaults when they are present:</p>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="operator">\</span><span class="variable">%defaults</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%user_input</span><span class="operator">]</span><span class="operator">);</span>
</code></pre>

<p>You can also use this to set two variables with the same name:</p>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">[{</span> <span class="string">v</span> <span class="operator">=&gt;</span> <span class="string">"The King"</span> <span class="operator">}</span><span class="operator">,</span>
                                    <span class="operator">{</span> <span class="string">v</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">]</span> <span class="operator">}</span><span class="operator">,</span>
                                   <span class="operator">]</span>
                          <span class="operator">);</span>
</code></pre>

<p>This sets <code>$v</code> to <code>&quot;The King&quot;</code> and <code>@v</code> to <code>(1,2,3)</code>.</p>

</dd>
<dt id="BROKEN1"><code>BROKEN</code></dt>
<dd>

<p>If any of the program fragments fails to compile or aborts for any reason, and you have set the <code>BROKEN</code> option to a function reference, <code>Text::Template</code> will invoke the function. This function is called the <i><code>BROKEN</code> function</i>. The <code>BROKEN</code> function will tell <code>Text::Template</code> what to do next.</p>

<p>If the <code>BROKEN</code> function returns <code>undef</code>, <code>Text::Template</code> will immediately abort processing the template and return the text that it has accumulated so far. If your function does this, it should set a flag that you can examine after <code>fill_in</code> returns so that you can tell whether there was a premature return or not.</p>

<p>If the <code>BROKEN</code> function returns any other value, that value will be interpolated into the template as if that value had been the return value of the program fragment to begin with. For example, if the <code>BROKEN</code> function returns an error string, the error string will be interpolated into the output of the template in place of the program fragment that cased the error.</p>

<p>If you don&#39;t specify a <code>BROKEN</code> function, <code>Text::Template</code> supplies a default one that returns something like</p>

<pre><code>        Program fragment delivered error ``Illegal division by 0 at
        template line 37&#39;&#39;</code></pre>

<p>(Note that the format of this message has changed slightly since version 1.31.) The return value of the <code>BROKEN</code> function is interpolated into the template at the place the error occurred, so that this template:</p>

<pre><code>        <span class="operator">(</span><span class="number">3</span><span class="operator">+</span><span class="number">4</span><span class="operator">)*</span><span class="number">5</span> <span class="operator">=</span> <span class="operator">{</span> <span class="number">3</span><span class="operator">+</span><span class="number">4</span><span class="operator">)*</span><span class="number">5</span> <span class="operator">}</span>
</code></pre>

<p>yields this result:</p>

<pre><code>        (3+4)*5 = Program fragment delivered error ``syntax error at template line 1&#39;&#39;</code></pre>

<p>If you specify a value for the <code>BROKEN</code> attribute, it should be a reference to a function that <code>fill_in</code> can call instead of the default function.</p>

<p><code>fill_in</code> will pass a hash to the <code>broken</code> function. The hash will have at least these three members:</p>

<dl>

<dt id="text"><code>text</code></dt>
<dd>

<p>The source code of the program fragment that failed</p>

</dd>
<dt id="error"><code>error</code></dt>
<dd>

<p>The text of the error message (<code>$@</code>) generated by eval.</p>

<p>The text has been modified to omit the trailing newline and to include the name of the template file (if there was one). The line number counts from the beginning of the template, not from the beginning of the failed program fragment.</p>

</dd>
<dt id="lineno"><code>lineno</code></dt>
<dd>

<p>The line number of the template at which the program fragment began.</p>

</dd>
</dl>

<p>There may also be an <code>arg</code> member. See <code>BROKEN_ARG</code>, below</p>

</dd>
<dt id="BROKEN_ARG"><code>BROKEN_ARG</code></dt>
<dd>

<p>If you supply the <code>BROKEN_ARG</code> option to <code>fill_in</code>, the value of the option is passed to the <code>BROKEN</code> function whenever it is called. The default <code>BROKEN</code> function ignores the <code>BROKEN_ARG</code>, but you can write a custom <code>BROKEN</code> function that uses the <code>BROKEN_ARG</code> to get more information about what went wrong.</p>

<p>The <code>BROKEN</code> function could also use the <code>BROKEN_ARG</code> as a reference to store an error message or some other information that it wants to communicate back to the caller. For example:</p>

<pre><code>        <span class="variable">$error</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
        
        <span class="keyword">sub</span><span class="variable"> my_broken </span><span class="operator">{</span> 
           <span class="keyword">my</span> <span class="variable">%args</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
           <span class="keyword">my</span> <span class="variable">$err_ref</span> <span class="operator">=</span> <span class="variable">$args</span><span class="operator">{</span><span class="string">arg</span><span class="operator">}</span><span class="operator">;</span>
           <span class="operator">...</span>
           <span class="variable">$$err_ref</span> <span class="operator">=</span> <span class="string">"Some error message"</span><span class="operator">;</span>
           <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
        <span class="operator">}</span>
        
        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">BROKEN</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">my_broken</span><span class="operator">,</span>
                           <span class="string">BROKEN_ARG</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$error</span><span class="operator">,</span>
                          <span class="operator">);</span>
        
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$error</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="keyword">die</span> <span class="string">"It didn't work: </span><span class="variable">$error</span><span class="string">"</span><span class="operator">;</span>
        <span class="operator">}</span>
</code></pre>

<p>If one of the program fragments in the template fails, it will call the <code>BROKEN</code> function, <code>my_broken</code>, and pass it the <code>BROKEN_ARG</code>, which is a reference to <code>$error</code>. <code>my_broken</code> can store an error message into <code>$error</code> this way. Then the function that called <code>fill_in</code> can see if <code>my_broken</code> has left an error message for it to find, and proceed accordingly.</p>

</dd>
<dt id="SAFE"><code>SAFE</code></dt>
<dd>

<p>If you give <code>fill_in</code> a <code>SAFE</code> option, its value should be a safe compartment object from the <code>Safe</code> package. All evaluation of program fragments will be performed in this compartment. See <a href="../../../lib/Safe.html">Safe</a> for full details about such compartments and how to restrict the operations that can be performed in them.</p>

<p>If you use the <code>PACKAGE</code> option with <code>SAFE</code>, the package you specify will be placed into the safe compartment and evaluation will take place in that package as usual.</p>

<p>If not, <code>SAFE</code> operation is a little different from the default. Usually, if you don&#39;t specify a package, evaluation of program fragments occurs in the package from which the template was invoked. But in <code>SAFE</code> mode the evaluation occurs inside the safe compartment and cannot affect the calling package. Normally, if you use <code>HASH</code> without <code>PACKAGE</code>, the hash variables are imported into a private, one-use-only package. But if you use <code>HASH</code> and <code>SAFE</code> together without <code>PACKAGE</code>, the hash variables will just be loaded into the root namespace of the <code>Safe</code> compartment.</p>

</dd>
<dt id="OUTPUT"><code>OUTPUT</code></dt>
<dd>

<p>If your template is going to generate a lot of text that you are just going to print out again anyway, you can save memory by having <code>Text::Template</code> print out the text as it is generated instead of making it into a big string and returning the string. If you supply the <code>OUTPUT</code> option to <code>fill_in</code>, the value should be a filehandle. The generated text will be printed to this filehandle as it is constructed. For example:</p>

<pre><code>        <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">fill_in</span><span class="operator">(</span><span class="string">OUTPUT</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">*STDOUT</span><span class="operator">,</span> <span class="operator">...);</span>
</code></pre>

<p>fills in the <code>$template</code> as usual, but the results are immediately printed to STDOUT. This may result in the output appearing more quickly than it would have otherwise.</p>

<p>If you use <code>OUTPUT</code>, the return value from <code>fill_in</code> is still true on success and false on failure, but the complete text is not returned to the caller.</p>

</dd>
<dt id="PREPEND1"><code>PREPEND</code></dt>
<dd>

<p>You can have some Perl code prepended automatically to the beginning of every program fragment. See <a href="#PREPEND-feature-and-using-strict-in-templates">&quot;<code>PREPEND</code> feature and using <code>strict</code> in templates&quot;</a> below.</p>

</dd>
<dt id="DELIMITERS1"><code>DELIMITERS</code></dt>
<dd>

<p>If this option is present, its value should be a reference to a list of two strings. The first string is the string that signals the beginning of each program fragment, and the second string is the string that signals the end of each program fragment. See <a href="#Alternative-Delimiters">&quot;Alternative Delimiters&quot;</a>, below.</p>

<p>If you specify <code>DELIMITERS</code> in the call to <code>fill_in</code>, they override any delimiters you set when you created the template object with <code>new</code>.</p>

</dd>
</dl>

<h1 id="Convenience-Functions">Convenience Functions</h1>

<h2 id="fill_this_in"><code>fill_this_in</code></h2>

<p>The basic way to fill in a template is to create a template object and then call <code>fill_in</code> on it. This is useful if you want to fill in the same template more than once.</p>

<p>In some programs, this can be cumbersome. <code>fill_this_in</code> accepts a string, which contains the template, and a list of options, which are passed to <code>fill_in</code> as above. It constructs the template object for you, fills it in as specified, and returns the results. It returns <code>undef</code> and sets <code>$Text::Template::ERROR</code> if it couldn&#39;t generate any results.</p>

<p>An example:</p>

<pre><code>        <span class="variable">$Q::name</span> <span class="operator">=</span> <span class="string">'Donald'</span><span class="operator">;</span>
        <span class="variable">$Q::amount</span> <span class="operator">=</span> <span class="number">141.61</span><span class="operator">;</span>
        <span class="variable">$Q::part</span> <span class="operator">=</span> <span class="string">'hyoid bone'</span><span class="operator">;</span>
        
        <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">fill_this_in</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">'EOM'</span><span class="operator">,</span> <span class="string">PACKAGE</span> <span class="operator">=&gt;</span> <span class="variable">Q</span><span class="operator">);</span><span class="string">
        Dear {$name},
        You owe me \\${sprintf('%.2f', $amount)}.  
        Pay or I will break your {$part}.
                Love,
                Grand Vizopteryx of Irkutsk.
        </span><span class="default">EOM</span>
</code></pre>

<p>Notice how we included the template in-line in the program by using a `here document&#39; with the <code>&lt;&lt;</code> notation.</p>

<p><code>fill_this_in</code> is a deprecated feature. It is only here for backwards compatibility, and may be removed in some far-future version in <code>Text::Template</code>. You should use <code>fill_in_string</code> instead. It is described in the next section.</p>

<h2 id="fill_in_string"><code>fill_in_string</code></h2>

<p>It is stupid that <code>fill_this_in</code> is a class method. It should have been just an imported function, so that you could omit the <code>Text::Template-&gt;</code> in the example above. But I made the mistake four years ago and it is too late to change it.</p>

<p><code>fill_in_string</code> is exactly like <code>fill_this_in</code> except that it is not a method and you can omit the <code>Text::Template-&gt;</code> and just say</p>

<pre><code>        <span class="keyword">print</span> <span class="variable">fill_in_string</span><span class="operator">(&lt;&lt;</span><span class="default">'EOM'</span><span class="operator">,</span> <span class="operator">...);</span><span class="string">
        Dear {$name},
          ...
        </span><span class="default">EOM</span>
</code></pre>

<p>To use <code>fill_in_string</code>, you need to say</p>

<pre><code>        <span class="keyword">use</span> <span class="variable">Text::Template</span> <span class="string">'fill_in_string'</span><span class="operator">;</span>
</code></pre>

<p>at the top of your program. You should probably use <code>fill_in_string</code> instead of <code>fill_this_in</code>.</p>

<h2 id="fill_in_file"><code>fill_in_file</code></h2>

<p>If you import <code>fill_in_file</code>, you can say</p>

<pre><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_file</span><span class="operator">(</span><span class="variable">filename</span><span class="operator">,</span> <span class="operator">...);</span>
</code></pre>

<p>The <code>...</code> are passed to <code>fill_in</code> as above. The filename is the name of the file that contains the template you want to fill in. It returns the result text. or <code>undef</code>, as usual.</p>

<p>If you are going to fill in the same file more than once in the same program you should use the longer <code>new</code> / <code>fill_in</code> sequence instead. It will be a lot faster because it only has to read and parse the file once.</p>

<h2 id="Including-files-into-templates">Including files into templates</h2>

<p>People always ask for this. ``Why don&#39;t you have an include function?&#39;&#39; they want to know. The short answer is this is Perl, and Perl already has an include function. If you want it, you can just put</p>

<pre><code>        <span class="operator">{</span><span class="string">qx{cat filename}</span><span class="operator">}</span>
</code></pre>

<p>into your template. Voil&agrave;.</p>

<p>If you don&#39;t want to use <code>cat</code>, you can write a little four-line function that opens a file and dumps out its contents, and call it from the template. I wrote one for you. In the template, you can say</p>

<pre><code>        <span class="operator">{</span><span class="variable">Text::Template::_load_text</span><span class="operator">(</span><span class="variable">filename</span><span class="operator">)}</span>
</code></pre>

<p>If that is too verbose, here is a trick. Suppose the template package that you are going to be mentioning in the <code>fill_in</code> call is package <code>Q</code>. Then in the main program, write</p>

<pre><code>        <span class="variable">*Q::include</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">Text::Template::_load_text</span><span class="operator">;</span>
</code></pre>

<p>This imports the <code>_load_text</code> function into package <code>Q</code> with the name <code>include</code>. From then on, any template that you fill in with package <code>Q</code> can say</p>

<pre><code>        <span class="operator">{</span><span class="variable">include</span><span class="operator">(</span><span class="variable">filename</span><span class="operator">)}</span>
</code></pre>

<p>to insert the text from the named file at that point. If you are using the <code>HASH</code> option instead, just put <code>include =&gt; \&amp;Text::Template::_load_text</code> into the hash instead of importing it explicitly.</p>

<p>Suppose you don&#39;t want to insert a plain text file, but rather you want to include one template within another? Just use <code>fill_in_file</code> in the template itself:</p>

<pre><code>        <span class="operator">{</span><span class="variable">Text::Template::fill_in_file</span><span class="operator">(</span><span class="variable">filename</span><span class="operator">)}</span>
</code></pre>

<p>You can do the same importing trick if this is too much to type.</p>

<h1 id="Miscellaneous">Miscellaneous</h1>

<h2 id="my-variables"><code>my</code> variables</h2>

<p>People are frequently surprised when this doesn&#39;t work:</p>

<pre><code>        <span class="keyword">my</span> <span class="variable">$recipient</span> <span class="operator">=</span> <span class="string">'The King'</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_file</span><span class="operator">(</span><span class="string">'formletter.tmpl'</span><span class="operator">);</span>
</code></pre>

<p>The text <code>The King</code> doesn&#39;t get into the form letter. Why not? Because <code>$recipient</code> is a <code>my</code> variable, and the whole point of <code>my</code> variables is that they&#39;re private and inaccessible except in the scope in which they&#39;re declared. The template is not part of that scope, so the template can&#39;t see <code>$recipient</code>.</p>

<p>If that&#39;s not the behavior you want, don&#39;t use <code>my</code>. <code>my</code> means a private variable, and in this case you don&#39;t want the variable to be private. Put the variables into package variables in some other package, and use the <code>PACKAGE</code> option to <code>fill_in</code>:</p>

<pre><code>        <span class="variable">$Q::recipient</span> <span class="operator">=</span> <span class="variable">$recipient</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_file</span><span class="operator">(</span><span class="string">'formletter.tmpl'</span><span class="operator">,</span> <span class="string">PACKAGE</span> <span class="operator">=&gt;</span> <span class="string">'Q'</span><span class="operator">);</span>
</code></pre>

<p>or pass the names and values in a hash with the <code>HASH</code> option:</p>

<pre><code>        <span class="keyword">my</span> <span class="variable">$text</span> <span class="operator">=</span> <span class="variable">fill_in_file</span><span class="operator">(</span><span class="string">'formletter.tmpl'</span><span class="operator">,</span> <span class="string">HASH</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">recipient</span> <span class="operator">=&gt;</span> <span class="variable">$recipient</span> <span class="operator">}</span><span class="operator">);</span>
</code></pre>

<h2 id="Security-Matters">Security Matters</h2>

<p>All variables are evaluated in the package you specify with the <code>PACKAGE</code> option of <code>fill_in</code>. if you use this option, and if your templates don&#39;t do anything egregiously stupid, you won&#39;t have to worry that evaluation of the little programs will creep out into the rest of your program and wreck something.</p>

<p>Nevertheless, there&#39;s really no way (except with <code>Safe</code>) to protect against a template that says</p>

<pre><code>        <span class="operator">{</span> <span class="variable">$Important::Secret::Security::Enable</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> 
          <span class="comment"># Disable security checks in this program </span>
        <span class="operator">}</span>
</code></pre>

<p>or</p>

<pre><code>        <span class="operator">{</span> <span class="variable">$/</span> <span class="operator">=</span> <span class="string">"ho ho ho"</span><span class="operator">;</span>   <span class="comment"># Sabotage future uses of &lt;FH&gt;.</span>
          <span class="comment"># $/ is always a global variable</span>
        <span class="operator">}</span>
</code></pre>

<p>or even</p>

<pre><code>        <span class="operator">{</span> <span class="keyword">system</span><span class="operator">(</span><span class="string">"rm -rf /"</span><span class="operator">)</span> <span class="operator">}</span>
</code></pre>

<p>so <b>don&#39;t</b> go filling in templates unless you&#39;re sure you know what&#39;s in them. If you&#39;re worried, or you can&#39;t trust the person who wrote the template, use the <code>SAFE</code> option.</p>

<p>A final warning: program fragments run a small risk of accidentally clobbering local variables in the <code>fill_in</code> function itself. These variables all have names that begin with <code>$fi_</code>, so if you stay away from those names you&#39;ll be safe. (Of course, if you&#39;re a real wizard you can tamper with them deliberately for exciting effects; this is actually how <code>$OUT</code> works.) I can fix this, but it will make the package slower to do it, so I would prefer not to. If you are worried about this, send me mail and I will show you what to do about it.</p>

<h2 id="Alternative-Delimiters">Alternative Delimiters</h2>

<p>Lorenzo Valdettaro pointed out that if you are using <code>Text::Template</code> to generate TeX output, the choice of braces as the program fragment delimiters makes you suffer suffer suffer. Starting in version 1.20, you can change the choice of delimiters to something other than curly braces.</p>

<p>In either the <code>new()</code> call or the <code>fill_in()</code> call, you can specify an alternative set of delimiters with the <code>DELIMITERS</code> option. For example, if you would like code fragments to be delimited by <code>[@--</code> and <code>--@]</code> instead of <code><span class="operator">{</span>
</code> and <code>}</code>, use</p>

<pre><code>        ... DELIMITERS =&gt; [ &#39;[@--&#39;, &#39;--@]&#39; ], ...</code></pre>

<p>Note that these delimiters are <i>literal strings</i>, not regexes. (I tried for regexes, but it complicates the lexical analysis too much.) Note also that <code>DELIMITERS</code> disables the special meaning of the backslash, so if you want to include the delimiters in the literal text of your template file, you are out of luck---it is up to you to choose delimiters that do not conflict with what you are doing. The delimiter strings may still appear inside of program fragments as long as they nest properly. This means that if for some reason you absolutely must have a program fragment that mentions one of the delimiters, like this:</p>

<pre><code>        [@--
                print &quot;Oh no, a delimiter: --@]\n&quot;
        --@]</code></pre>

<p>you may be able to make it work by doing this instead:</p>

<pre><code>        [@--
                # Fake matching delimiter in a comment: [@--
                print &quot;Oh no, a delimiter: --@]\n&quot;
        --@]</code></pre>

<p>It may be safer to choose delimiters that begin with a newline character.</p>

<p>Because the parsing of templates is simplified by the absence of backslash escapes, using alternative <code>DELIMITERS</code> may speed up the parsing process by 20-25%. This shows that my original choice of <code><span class="operator">{</span>
</code> and <code>}</code> was very bad.</p>

<h2 id="PREPEND-feature-and-using-strict-in-templates"><code>PREPEND</code> feature and using <code>strict</code> in templates</h2>

<p>Suppose you would like to use <code>strict</code> in your templates to detect undeclared variables and the like. But each code fragment is a separate lexical scope, so you have to turn on <code>strict</code> at the top of each and every code fragment:</p>

<pre><code>        <span class="operator">{</span> <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
          <span class="keyword">use</span> <span class="variable">vars</span> <span class="string">'$foo'</span><span class="operator">;</span>
          <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">14</span><span class="operator">;</span>
          <span class="operator">...</span>
        <span class="operator">}</span>
        
        <span class="operator">...</span>
        
        <span class="operator">{</span> <span class="comment"># we forgot to put `use strict' here</span>
          <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$boo</span> <span class="operator">+</span> <span class="number">12</span><span class="operator">;</span>    <span class="comment"># $boo is misspelled and should be $foo</span>
          <span class="comment"># No error is raised on `$boo'</span>
        <span class="operator">}</span>
</code></pre>

<p>Because we didn&#39;t put <code>use strict</code> at the top of the second fragment, it was only active in the first fragment, and we didn&#39;t get any <code>strict</code> checking in the second fragment. Then we mispelled <code>$foo</code> and the error wasn&#39;t caught.</p>

<p><code>Text::Template</code> version 1.22 and higher has a new feature to make this easier. You can specify that any text at all be automatically added to the beginning of each program fragment.</p>

<p>When you make a call to <code>fill_in</code>, you can specify a</p>

<pre><code>        PREPEND =&gt; &#39;some perl statements here&#39;</code></pre>

<p>option; the statements will be prepended to each program fragment for that one call only. Suppose that the <code>fill_in</code> call included a</p>

<pre><code>        <span class="string">PREPEND</span> <span class="operator">=&gt;</span> <span class="string">'use strict;'</span>
</code></pre>

<p>option, and that the template looked like this:</p>

<pre><code>        <span class="operator">{</span> <span class="keyword">use</span> <span class="variable">vars</span> <span class="string">'$foo'</span><span class="operator">;</span>
          <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">14</span><span class="operator">;</span>
          <span class="operator">...</span>
        <span class="operator">}</span>
        
        <span class="operator">...</span>
        
        <span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$boo</span> <span class="operator">+</span> <span class="number">12</span><span class="operator">;</span>    <span class="comment"># $boo is misspelled and should be $foo</span>
          <span class="operator">...</span>
        <span class="operator">}</span>
</code></pre>

<p>The code in the second fragment would fail, because <code>$boo</code> has not been declared. <code>use strict</code> was implied, even though you did not write it explicitly, because the <code>PREPEND</code> option added it for you automatically.</p>

<p>There are two other ways to do this. At the time you create the template object with <code>new</code>, you can also supply a <code>PREPEND</code> option, in which case the statements will be prepended each time you fill in that template. If the <code>fill_in</code> call has its own <code>PREPEND</code> option, this overrides the one specified at the time you created the template. Finally, you can make the class method call</p>

<pre><code>        <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">always_prepend</span><span class="operator">(</span><span class="string">'perl statements'</span><span class="operator">);</span>
</code></pre>

<p>If you do this, then call calls to <code>fill_in</code> for <i>any</i> template will attach the perl statements to the beginning of each program fragment, except where overridden by <code>PREPEND</code> options to <code>new</code> or <code>fill_in</code>.</p>

<h2 id="Prepending-in-Derived-Classes">Prepending in Derived Classes</h2>

<p>This section is technical, and you should skip it on the first few readings.</p>

<p>Normally there are three places that prepended text could come from. It could come from the <code>PREPEND</code> option in the <code>fill_in</code> call, from the <code>PREPEND</code> option in the <code>new</code> call that created the template object, or from the argument of the <code>always_prepend</code> call. <code>Text::Template</code> looks for these three things in order and takes the first one that it finds.</p>

<p>In a subclass of <code>Text::Template</code>, this last possibility is ambiguous. Suppose <code>S</code> is a subclass of <code>Text::Template</code>. Should</p>

<pre><code>        <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">always_prepend</span><span class="operator">(...);</span>
</code></pre>

<p>affect objects in class <code>Derived</code>? The answer is that you can have it either way.</p>

<p>The <code>always_prepend</code> value for <code>Text::Template</code> is normally stored in a hash variable named <code>%GLOBAL_PREPEND</code> under the key <code>Text::Template</code>. When <code>Text::Template</code> looks to see what text to prepend, it first looks in the template object itself, and if not, it looks in <code><span class="variable">$GLOBAL_PREPEND</span><span class="operator">{</span>
<i>class</i>}</code> where <i>class</i> is the class to which the template object belongs. If it doesn&#39;t find any value, it looks in <code><span class="variable">$GLOBAL_PREPEND</span><span class="operator">{</span><span class="string">'Text::Template'</span><span class="operator">}</span>
</code>. This means that objects in class <code>Derived</code> <i>will</i> be affected by</p>

<pre><code>        <span class="variable">Text::Template</span><span class="operator">-&gt;</span><span class="variable">always_prepend</span><span class="operator">(...);</span>
</code></pre>

<p><i>unless</i> there is also a call to</p>

<pre><code>        <span class="variable">Derived</span><span class="operator">-&gt;</span><span class="variable">always_prepend</span><span class="operator">(...);</span>
</code></pre>

<p>So when you&#39;re designing your derived class, you can arrange to have your objects ignore <code>Text::Template::always_prepend</code> calls by simply putting <code>Derived-&gt;always_prepend(&#39;&#39;)</code> at the top of your module.</p>

<p>Of course, there is also a final escape hatch: Templates support a <code>prepend_text</code> that is used to look up the appropriate text to be prepended at <code>fill_in</code> time. Your derived class can override this method to get an arbitrary effect.</p>

<h2 id="JavaScript">JavaScript</h2>

<p>Jennifer D. St Clair asks:</p>

<pre><code>        &gt; Most of my pages contain JavaScript and Stylesheets.
        &gt; How do I change the template identifier?  </code></pre>

<p>Jennifer is worried about the braces in the JavaScript being taken as the delimiters of the Perl program fragments. Of course, disaster will ensue when perl tries to evaluate these as if they were Perl programs. The best choice is to find some unambiguous delimiter strings that you can use in your template instead of curly braces, and then use the <code>DELIMITERS</code> option. However, if you can&#39;t do this for some reason, there are two easy workarounds:</p>

<p>1. You can put <code>\</code> in front of <code><span class="operator">{</span>
</code>, <code>}</code>, or <code>\</code> to remove its special meaning. So, for example, instead of</p>

<pre><code>            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">br</span><span class="operator">==</span> <span class="string">"n3"</span><span class="operator">)</span> <span class="operator">{</span> 
                <span class="regex">//</span> <span class="variable">etc</span><span class="operator">.</span>
            <span class="operator">}</span>
</code></pre>

<p>you can put</p>

<pre><code>            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">br</span><span class="operator">==</span> <span class="string">"n3"</span><span class="operator">)</span> <span class="operator">\</span><span class="operator">{</span> 
                <span class="regex">//</span> <span class="variable">etc</span><span class="operator">.</span>
            <span class="operator">\</span><span class="operator">}</span>
</code></pre>

<p>and it&#39;ll come out of the template engine the way you want.</p>

<p>But here is another method that is probably better. To see how it works, first consider what happens if you put this into a template:</p>

<pre><code>            <span class="operator">{</span> <span class="string">'foo'</span> <span class="operator">}</span>
</code></pre>

<p>Since it&#39;s in braces, it gets evaluated, and obviously, this is going to turn into</p>

<pre><code>            foo</code></pre>

<p>So now here&#39;s the trick: In Perl, <code><span class="string">q{...}</span>
</code> is the same as <code>&#39;...&#39;</code>. So if we wrote</p>

<pre><code>            <span class="operator">{</span><span class="string">q{foo}</span><span class="operator">}</span>
</code></pre>

<p>it would turn into</p>

<pre><code>            foo</code></pre>

<p>So for your JavaScript, just write</p>

<pre><code>            <span class="operator">{</span><span class="string">q{if (br== "n3") { 
                 // etc.
               }}</span>
            <span class="operator">}</span>
</code></pre>

<p>and it&#39;ll come out as</p>

<pre><code>              <span class="keyword">if</span> <span class="operator">(</span><span class="variable">br</span><span class="operator">==</span> <span class="string">"n3"</span><span class="operator">)</span> <span class="operator">{</span> 
                  <span class="regex">//</span> <span class="variable">etc</span><span class="operator">.</span>
              <span class="operator">}</span>
</code></pre>

<p>which is what you want.</p>

<h2 id="Shut-Up">Shut Up!</h2>

<p>People sometimes try to put an initialization section at the top of their templates, like this:</p>

<pre><code>        <span class="operator">{</span> <span class="operator">...</span>
          <span class="variable">$var</span> <span class="operator">=</span> <span class="number">17</span><span class="operator">;</span>
        <span class="operator">}</span>
</code></pre>

<p>Then they complain because there is a <code>17</code> at the top of the output that they didn&#39;t want to have there.</p>

<p>Remember that a program fragment is replaced with its own return value, and that in Perl the return value of a code block is the value of the last expression that was evaluated, which in this case is 17. If it didn&#39;t do that, you wouldn&#39;t be able to write <code><span class="operator">{</span><span class="variable">$recipient</span><span class="operator">}</span>
</code> and have the recipient filled in.</p>

<p>To prevent the 17 from appearing in the output is very simple:</p>

<pre><code>        <span class="operator">{</span> <span class="operator">...</span>
          <span class="variable">$var</span> <span class="operator">=</span> <span class="number">17</span><span class="operator">;</span>
          <span class="string">''</span><span class="operator">;</span>
        <span class="operator">}</span>
</code></pre>

<p>Now the last expression evaluated yields the empty string, which is invisible. If you don&#39;t like the way this looks, use</p>

<pre><code>        <span class="operator">{</span> <span class="operator">...</span>
          <span class="variable">$var</span> <span class="operator">=</span> <span class="number">17</span><span class="operator">;</span>
          <span class="operator">(</span><span class="variable">$SILENTLY</span><span class="operator">);</span>
        <span class="operator">}</span>
</code></pre>

<p>instead. Presumably, <code>$SILENTLY</code> has no value, so nothing will be interpolated. This is what is known as a `trick&#39;.</p>

<h2 id="Compatibility">Compatibility</h2>

<p>Every effort has been made to make this module compatible with older versions. The only known exceptions follow:</p>

<p>The output format of the default <code>BROKEN</code> subroutine has changed twice, most recently between versions 1.31 and 1.40.</p>

<p>Starting in version 1.10, the <code>$OUT</code> variable is arrogated for a special meaning. If you had templates before version 1.10 that happened to use a variable named <code>$OUT</code>, you will have to change them to use some other variable or all sorts of strangeness will result.</p>

<p>Between versions 0.1b and 1.00 the behavior of the \ metacharacter changed. In 0.1b, \\ was special everywhere, and the template processor always replaced it with a single backslash before passing the code to Perl for evaluation. The rule now is more complicated but probably more convenient. See the section on backslash processing, below, for a full discussion.</p>

<h2 id="Backslash-Processing">Backslash Processing</h2>

<p>In <code>Text::Template</code> beta versions, the backslash was special whenever it appeared before a brace or another backslash. That meant that while <code><span class="operator">{</span><span class="string">"\n"</span><span class="operator">}</span>
</code> did indeed generate a newline, <code><span class="operator">{</span><span class="string">"\\"</span><span class="operator">}</span>
</code> did not generate a backslash, because the code passed to Perl for evaluation was <code>&quot;\&quot;</code> which is a syntax error. If you wanted a backslash, you would have had to write <code><span class="operator">{</span><span class="string">"\\\\"</span><span class="operator">}</span>
</code>.</p>

<p>In <code>Text::Template</code> versions 1.00 through 1.10, there was a bug: Backslash was special everywhere. In these versions, <code><span class="operator">{</span><span class="string">"\n"</span><span class="operator">}</span>
</code> generated the letter <code>n</code>.</p>

<p>The bug has been corrected in version 1.11, but I did not go back to exactly the old rule, because I did not like the idea of having to write <code><span class="operator">{</span><span class="string">"\\\\"</span><span class="operator">}</span>
</code> to get one backslash. The rule is now more complicated to remember, but probably easier to use. The rule is now: Backslashes are always passed to Perl unchanged <i>unless</i> they occur as part of a sequence like <code><span class="operator">\\\\\\</span><span class="operator">{</span>
</code> or <code>\\\\\\}</code>. In these contexts, they are special; <code>\\</code> is replaced with <code>\</code>, and <code><span class="operator">\</span><span class="operator">{</span>
</code> and <code>\}</code> signal a literal brace.</p>

<p>Examples:</p>

<pre><code>        <span class="operator">\</span><span class="operator">{</span> <span class="variable">foo</span> <span class="operator">\</span><span class="operator">}</span>
</code></pre>

<p>is <i>not</i> evaluated, because the <code>\</code> before the braces signals that they should be taken literally. The result in the output looks like this:</p>

<pre><code>        <span class="operator">{</span> <span class="variable">foo</span> <span class="operator">}</span>
</code></pre>

<p>This is a syntax error:</p>

<pre><code>        <span class="operator">{</span> <span class="string">"foo}"</span> <span class="operator">}</span>
</code></pre>

<p>because <code>Text::Template</code> thinks that the code ends at the first <code>}</code>, and then gets upset when it sees the second one. To make this work correctly, use</p>

<pre><code>        <span class="operator">{</span> <span class="string">"foo\}"</span> <span class="operator">}</span>
</code></pre>

<p>This passes <code>&quot;foo}&quot;</code> to Perl for evaluation. Note there&#39;s no <code>\</code> in the evaluated code. If you really want a <code>\</code> in the evaluated code, use</p>

<pre><code>        <span class="operator">{</span> <span class="string">"foo\\\}"</span> <span class="operator">}</span>
</code></pre>

<p>This passes <code>&quot;foo\}&quot;</code> to Perl for evaluation.</p>

<p>Starting with <code>Text::Template</code> version 1.20, backslash processing is disabled if you use the <code>DELIMITERS</code> option to specify alternative delimiter strings.</p>

<h2 id="A-short-note-about-Text::Template::ERROR">A short note about <code>$Text::Template::ERROR</code></h2>

<p>In the past some people have fretted about `violating the package boundary&#39; by examining a variable inside the <code>Text::Template</code> package. Don&#39;t feel this way. <code>$Text::Template::ERROR</code> is part of the published, official interface to this package. It is perfectly OK to inspect this variable. The interface is not going to change.</p>

<p>If it really, really bothers you, you can import a function called <code>TTerror</code> that returns the current value of the <code>$ERROR</code> variable. So you can say:</p>

<pre><code>        <span class="keyword">use</span> <span class="variable">Text::Template</span> <span class="string">'TTerror'</span><span class="operator">;</span>
        
        <span class="keyword">my</span> <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span><span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="variable">$filename</span><span class="operator">);</span>
        <span class="keyword">unless</span> <span class="operator">(</span><span class="variable">$template</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="keyword">my</span> <span class="variable">$err</span> <span class="operator">=</span> <span class="variable">TTerror</span><span class="operator">;</span>
          <span class="keyword">die</span> <span class="string">"Couldn't make template: </span><span class="variable">$err</span><span class="string">; aborting"</span><span class="operator">;</span>
        <span class="operator">}</span>
</code></pre>

<p>I don&#39;t see what benefit this has over just doing this:</p>

<pre><code>        <span class="keyword">use</span> <span class="variable">Text::Template</span><span class="operator">;</span>
        
        <span class="keyword">my</span> <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Text::Template</span> <span class="operator">(</span><span class="string">SOURCE</span> <span class="operator">=&gt;</span> <span class="variable">$filename</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't make template: </span><span class="variable">$Text</span><span class="string">::Template::ERROR; aborting"</span><span class="operator">;</span>
</code></pre>

<p>But if it makes you happy to do it that way, go ahead.</p>

<h2 id="Sticky-Widgets-in-Template-Files">Sticky Widgets in Template Files</h2>

<p>The <code>CGI</code> module provides functions for `sticky widgets&#39;, which are form input controls that retain their values from one page to the next. Sometimes people want to know how to include these widgets into their template output.</p>

<p>It&#39;s totally straightforward. Just call the <code>CGI</code> functions from inside the template:</p>

<pre><code>        <span class="operator">{</span> <span class="variable">$q</span><span class="operator">-&gt;</span><span class="variable">checkbox_group</span><span class="operator">(</span><span class="string">NAME</span> <span class="operator">=&gt;</span> <span class="string">'toppings'</span><span class="operator">,</span>
                             <span class="string">LINEBREAK</span> <span class="operator">=&gt;</span> <span class="variable">true</span><span class="operator">,</span>
                             <span class="string">COLUMNS</span> <span class="operator">=&gt;</span> <span class="number">3</span><span class="operator">,</span>
                             <span class="string">VALUES</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@toppings</span><span class="operator">,</span>
                            <span class="operator">);</span>
        <span class="operator">}</span>
</code></pre>

<h2 id="Automatic-preprocessing-of-program-fragments">Automatic preprocessing of program fragments</h2>

<p>It may be useful to preprocess the program fragments before they are evaluated. See <code>Text::Template::Preprocess</code> for more details.</p>

<h2 id="Automatic-postprocessing-of-template-hunks">Automatic postprocessing of template hunks</h2>

<p>It may be useful to process hunks of output before they are appended to the result text. For this, subclass and replace the <code>append_text_to_result</code> method. It is passed a list of pairs with these entries:</p>

<pre><code>  handle - a filehandle to which to print the desired output
  out    - a ref to a string to which to append, to use if handle is not given
  text   - the text that will be appended
  type   - where the text came from: TEXT for literal text, PROG for code</code></pre>

<h2 id="Author">Author</h2>

<p>Mark Jason Dominus, Plover Systems</p>

<p>Please send questions and other remarks about this software to <code>mjd-perl-template+@plover.com</code></p>

<p>You can join a very low-volume (&lt;10 messages per year) mailing list for announcements about this package. Send an empty note to <code>mjd-perl-template-request@plover.com</code> to join.</p>

<p>For updates, visit <code>http://www.plover.com/~mjd/perl/Template/</code>.</p>

<h2 id="Support">Support?</h2>

<p>This software is version 1.46. It may have bugs. Suggestions and bug reports are always welcome. Send them to <code>mjd-perl-template+@plover.com</code>. (That is my address, not the address of the mailing list. The mailing list address is a secret.)</p>

<h1 id="LICENSE">LICENSE</h1>

<pre><code>    <span class="variable">Text::Template</span> <span class="variable">version</span> <span class="number">1.46</span>
    <span class="variable">Copyright</span> <span class="number">2013</span> <span class="variable">Mark</span> <span class="variable">Jason</span> <span class="variable">Dominus</span>
    
    <span class="variable">This</span> <span class="variable">program</span> <span class="variable">is</span> <span class="variable">free</span> <span class="variable">software</span><span class="operator">;</span> <span class="variable">you</span> <span class="variable">can</span> <span class="variable">redistribute</span> <span class="variable">it</span> <span class="keyword">and</span><span class="regex">/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.  You may also can
    redistribute it and/or</span> <span class="variable">modify</span> <span class="variable">it</span> <span class="variable">under</span> <span class="variable">the</span> <span class="variable">terms</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">Perl</span>
    <span class="variable">Artistic</span> <span class="variable">License</span><span class="operator">.</span>
    
    <span class="variable">This</span> <span class="variable">program</span> <span class="variable">is</span> <span class="variable">distributed</span> <span class="variable">in</span> <span class="variable">the</span> <span class="variable">hope</span> <span class="variable">that</span> <span class="variable">it</span> <span class="variable">will</span> <span class="variable">be</span> <span class="variable">useful</span><span class="operator">,</span>
    <span class="variable">but</span> <span class="variable">WITHOUT</span> <span class="variable">ANY</span> <span class="variable">WARRANTY</span><span class="operator">;</span> <span class="variable">without</span> <span class="variable">even</span> <span class="variable">the</span> <span class="variable">implied</span> <span class="variable">warranty</span> <span class="variable">of</span>
    <span class="variable">MERCHANTABILITY</span> <span class="keyword">or</span> <span class="variable">FITNESS</span> <span class="variable">FOR</span> <span class="variable">A</span> <span class="variable">PARTICULAR</span> <span class="variable">PURPOSE</span><span class="operator">.</span>  <span class="variable">See</span> <span class="variable">the</span>
    <span class="variable">GNU</span> <span class="variable">General</span> <span class="variable">Public</span> <span class="variable">License</span> <span class="keyword">for</span> <span class="variable">more</span> <span class="variable">details</span><span class="operator">.</span>
    
    <span class="variable">You</span> <span class="variable">should</span> <span class="variable">have</span> <span class="variable">received</span> <span class="variable">copies</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">GNU</span> <span class="variable">General</span> <span class="variable">Public</span> <span class="variable">License</span>
    <span class="variable">along</span> <span class="variable">with</span> <span class="variable">this</span> <span class="variable">program</span><span class="operator">;</span> <span class="keyword">if</span> <span class="keyword">not</span><span class="operator">,</span> <span class="keyword">write</span> <span class="variable">to</span> <span class="variable">the</span> <span class="variable">Free</span> <span class="variable">Software</span>
    <span class="variable">Foundation</span><span class="operator">,</span> <span class="variable">Inc</span><span class="operator">.,</span> <span class="number">59</span> <span class="variable">Temple</span> <span class="variable">Place</span> <span class="operator">-</span> <span class="variable">Suite</span> <span class="number">330</span><span class="operator">,</span> <span class="variable">Boston</span><span class="operator">,</span> <span class="variable">MA</span> <span class="number">02111</span><span class="operator">-</span><span class="number">1307</span><span class="operator">,</span> <span class="variable">USA</span><span class="operator">.</span>
</code></pre>

<h1 id="THANKS">THANKS</h1>

<p>Many thanks to the following people for offering support, encouragement, advice, bug reports, and all the other good stuff.</p>

<p>David H. Adler / Joel Appelbaum / Klaus Arnhold / Ant&oacute;nio Arag&atilde;o / Kevin Atteson / Chris.Brezil / Mike Brodhead / Tom Brown / Dr. Frank Bucolo / Tim Bunce / Juan E. Camacho / Itamar Almeida de Carvalho / Joseph Cheek / Gene Damon / San Deng / Bob Dougherty / Marek Grac / Dan Franklin / gary at dls.net / Todd A. Green / Donald L. Greer Jr. / Michelangelo Grigni / Zac Hansen / Tom Henry / Jarko Hietaniemi / Matt X. Hunter / Robert M. Ioffe / Daniel LaLiberte / Reuven M. Lerner / Trip Lilley / Yannis Livassof / Val Luck / Kevin Madsen / David Marshall / James Mastros / Joel Meulenberg / Jason Moore / Sergey Myasnikov / Chris Nandor / Bek Oberin / Steve Palincsar / Ron Pero / Hans Persson / Sean Roehnelt / Jonathan Roy / Shabbir J. Safdar / Jennifer D. St Clair / Uwe Schneider / Randal L. Schwartz / Michael G Schwern / Yonat Sharon / Brian C. Shensky / Niklas Skoglund / Tom Snee / Fred Steinberg / Hans Stoop / Michael J. Suzio / Dennis Taylor / James H. Thompson / Shad Todd / Lieven Tomme / Lorenzo Valdettaro / Larry Virden / Andy Wardley / Archie Warnock / Chris Wesley / Matt Womer / Andrew G Wood / Daini Xie / Michaely Yeung</p>

<p>Special thanks to:</p>

<dl>

<dt id="Jonathan-Roy">Jonathan Roy</dt>
<dd>

<p>for telling me how to do the <code>Safe</code> support (I spent two years worrying about it, and then Jonathan pointed out that it was trivial.)</p>

</dd>
<dt id="Ranjit-Bhatnagar">Ranjit Bhatnagar</dt>
<dd>

<p>for demanding less verbose fragments like they have in ASP, for helping me figure out the Right Thing, and, especially, for talking me out of adding any new syntax. These discussions resulted in the <code>$OUT</code> feature.</p>

</dd>
</dl>

<h2 id="Bugs-and-Caveats">Bugs and Caveats</h2>

<p><code>my</code> variables in <code>fill_in</code> are still susceptible to being clobbered by template evaluation. They all begin with <code>fi_</code>, so avoid those names in your templates.</p>

<p>The line number information will be wrong if the template&#39;s lines are not terminated by <code>&quot;\n&quot;</code>. You should let me know if this is a problem. If you do, I will fix it.</p>

<p>The <code>$OUT</code> variable has a special meaning in templates, so you cannot use it as if it were a regular variable.</p>

<p>There are not quite enough tests in the test suite.</p>


</body>

</html>


